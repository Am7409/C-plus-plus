This is type of Data Strcuter or a combination of edges and nodes .

Q1 Implemantion of graph in the adjecny list form

        //Solution
          #include <bits/stdc++.h>
          using namespace std;

          class graph{
            public: 
             unordered_map<int,list<int>> mp;
            void insertEgde(int u,int v, bool direction){
                //If Direction = 0 -> undirected
                // If Deriection = 1 -> undirected
                mp[u].push_back(v);
                if(direction==0){
                    mp[v].push_back(u);
                }
            }

            void printAdjecylist(){
                for(auto it:mp){
                    cout<<it.first <<" : ";
                    for(auto i:it.second){
                        cout<<i <<", ";
                    }
                    cout<<endl;
                }
            }

          };
          int main() {
            int n,m;
            cout<<"Enter the number of Nodes : ";
            cin>>n;
            cout<<"\nEnter the Number of Edges : ";
            cin>>m;
            graph g;
            for(int i=0;i<m;i++){
                int u,v;
                cin>>u>>v;
                g.insertEgde(u,v,0);
            }
            cout<<endl;
            g.printAdjecylist();
            return 0;
          }


Q2: BFS of graph
   //Aproches
     //App1: For this we have to take the queue to store the nodes and its neighbour and a visited map for the replacing the chance of infinte loop between any
              printed node in the ans array;
              Firstly we have to store the first node and than store all it's neighbour in the queue and pop the front element from the queue and store it into the 
              ans vector;
              and also check any neighbour is also there which is in front of the queue;
              
              //Solutins
              
                vector<int> bfsOfGraph(int V, vector<int> adj[]) {
                        // Code here
                        unordered_map<int,bool> vis;
                        vector<int> ans;
                        queue<int> q;
                        q.push(0);
                        vis[0]=true;
                        while(q.size()>0){
                            int cur=q.front();
                            q.pop();
                            ans.push_back(cur);
                            for(auto i:adj[cur]){
                                if(vis[i]==false){
                                q.push(i);
                                    vis[i]=true;
                                }
                            }
                        }
                        return ans;
                    }


Q3: DFS of Graph
   //approches
      //App1 for this we have to solve by recursion 
             firstly we create a loop and in that we have to check each node on the graph 
             and than check into the more depth and in the function if the node's neighbur is not visited than mark it visited and check the same condition for its
               neighbour 
               
          //Sloutions 
             void solve(unordered_map<int,bool> &vis,vector<int> &ans,vector<int> adj[],int i){
                                 ans.push_back(i);
                                 vis[i]=true;
                                 for(auto it:adj[i]){
                                     if(!vis[it]){
                                         solve(vis,ans,adj,it);
                                     }
                                 }
                                 }
                            vector<int> dfsOfGraph(int V, vector<int> adj[]) {
                                // Code here
                                unordered_map<int,bool> vis;
                                vector<int> ans;
                                for(int i=0;i<V;i++){
                                    if(vis[i]==false){ 
                                        solve(vis,ans,adj,i);
                                    }
                                }
                                return ans;
                            }


Q4: Detect cycle in an undirected graph
    //Approcehs 
       //App1 this is by the bfs approach
              in this we same doing as we are do in the bfs but in this one more condition is also added that is if the visited is true for a node and it's parent is not
                equal to it's current node in the queue than the cycle is present in the graph
             //Solution 
                  bool iscyclic(int i,unordered_map<int,bool> &vis,vector<int>adj[] ){
                            queue<int> q;
                            unordered_map<int,int> part;
                            vis[i]=true;
                            part[i]=-1;
                            q.push(i);
                            while(q.empty()){
                                int cur=q.front();
                                q.pop();
                                for(auto it:adj[cur]){
                                if(vis[it]==true and part[cur]!=it){
                                    return true;
                                }
                                else if(!vis[it]){
                                    q.push(it);
                                    vis[it]=true;
                                    part[it]=cur;
                                }
                            }
                            }
                            return false;
                        }
                            bool isCycle(int V, vector<int> adj[]) {
                                // Code here
                                //Dection of cycle using the BFS way 
                                unordered_map<int,bool> vis;
                                unordered_map<int,list<int>> mp;
                               //to handle the dosconneced componants
                               for(int i=0;i<V;i++){
                                   if(vis[i]==0){
                                       if(iscyclic(i,vis,adj)){
                                           return true;
                                       }
                                   }

                               }
                                return false;
                            }
             
             
             //Approch 2 this is doing by the DFS approach 
               This is also same as that of DFS and just one add up is if the visited is true for a node and it's parent is not
                equal to it's current node than the cycle is present in the graph
                    //Solution 
                      bool detectdfs(vector<int> adj[],int vis[] ,int i,int part){
                                vis[i]=1;
                                for(auto it:adj[i]){
                                    if(!vis[it]){
                                        if(detectdfs(adj,vis,it,i)){
                                            return true;
                                        }
                                    }
                                    else if(it!=part) {
                                        // this means that cycle is present 
                                        return true;
                                    }
                                }
                                return false;
                            }

                          public:
                            bool isCycle(int V, vector<int> adj[]) {
                                int vis[V] = {0};
                                for(int i = 0 ; i < V ; i++) {
                                    if(vis[i] == 0) {
                                        if(detectdfs(adj , vis , i,-1)) return true;
                                    }
                                }
                                return false;
                            }


Q5: Detect cycle in a directed graph
    //Approches 
       //Approch 1 this is doing by the DFS approach 
               This is also same as that of DFS and just one add up is if the visited is true for a node and it's parent is
                equal to it's current node than the cycle is present in the graph
                    //Solution 
                      bool checkcycle(int i, unordered_map<int,bool> &vis,unordered_map<int,bool> &dfscheck,vector<int> adj[]){
                                vis[i]=true;
                                dfscheck[i]=true;
                                for(auto it:adj[i]){
                                    if(!vis[it]){
                                        if(checkcycle(it,vis,dfscheck,adj)){
                                            return true;
                                        }
                                    }
                                    else if(dfscheck[it]) {
                                       return true;    
                                    }
                                }
                                dfscheck[i]=false;
                                return false;
                            }
                            bool isCyclic(int V, vector<int> adj[]) {
                                // code here
                                //call dfs through for all componants
                                unordered_map<int,bool> vis;
                                unordered_map<int,bool> dfsvis;

                                for(int i=0;i<V;i++){
                                    if(!vis[i]){
                                        if(checkcycle(i,vis,dfsvis,adj)){
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            }
