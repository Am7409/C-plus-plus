This is type of Data Strcuter or a combination of edges and nodes .

Q1 Implemantion of graph in the adjecny list form

        //Solution
          #include <bits/stdc++.h>
          using namespace std;

          class graph{
            public: 
             unordered_map<int,list<int>> mp;
            void insertEgde(int u,int v, bool direction){
                //If Direction = 0 -> undirected
                // If Deriection = 1 -> undirected
                mp[u].push_back(v);
                if(direction==0){
                    mp[v].push_back(u);
                }
            }

            void printAdjecylist(){
                for(auto it:mp){
                    cout<<it.first <<" : ";
                    for(auto i:it.second){
                        cout<<i <<", ";
                    }
                    cout<<endl;
                }
            }

          };
          int main() {
            int n,m;
            cout<<"Enter the number of Nodes : ";
            cin>>n;
            cout<<"\nEnter the Number of Edges : ";
            cin>>m;
            graph g;
            for(int i=0;i<m;i++){
                int u,v;
                cin>>u>>v;
                g.insertEgde(u,v,0);
            }
            cout<<endl;
            g.printAdjecylist();
            return 0;
          }


Q2: BFS of graph
   //Aproches
     //App1: For this we have to take the queue to store the nodes and its neighbour and a visited map for the replacing the chance of infinte loop between any
              printed node in the ans array;
              Firstly we have to store the first node and than store all it's neighbour in the queue and pop the front element from the queue and store it into the 
              ans vector;
              and also check any neighbour is also there which is in front of the queue;
              
              //Solutins
              
                vector<int> bfsOfGraph(int V, vector<int> adj[]) {
                        // Code here
                        unordered_map<int,bool> vis;
                        vector<int> ans;
                        queue<int> q;
                        q.push(0);
                        vis[0]=true;
                        while(q.size()>0){
                            int cur=q.front();
                            q.pop();
                            ans.push_back(cur);
                            for(auto i:adj[cur]){
                                if(vis[i]==false){
                                q.push(i);
                                    vis[i]=true;
                                }
                            }
                        }
                        return ans;
                    }


Q3: DFS of Graph
   //approches
      //App1 for this we have to solve by recursion 
             firstly we create a loop and in that we have to check each node on the graph 
             and than check into the more depth and in the function if the node's neighbur is not visited than mark it visited and check the same condition for its
               neighbour 
               
          //Sloutions 
             void solve(unordered_map<int,bool> &vis,vector<int> &ans,vector<int> adj[],int i){
                                 ans.push_back(i);
                                 vis[i]=true;
                                 for(auto it:adj[i]){
                                     if(!vis[it]){
                                         solve(vis,ans,adj,it);
                                     }
                                 }
                                 }
                            vector<int> dfsOfGraph(int V, vector<int> adj[]) {
                                // Code here
                                unordered_map<int,bool> vis;
                                vector<int> ans;
                                for(int i=0;i<V;i++){
                                    if(vis[i]==false){ 
                                        solve(vis,ans,adj,i);
                                    }
                                }
                                return ans;
                            }


Q4: Detect cycle in an undirected graph
    //Approcehs 
       //App1 this is by the bfs approach
              in this we same doing as we are do in the bfs but in this one more condition is also added that is if the visited is true for a node and it's parent is not
                equal to it's current node in the queue than the cycle is present in the graph
             //Solution 
                  bool iscyclic(int i,unordered_map<int,bool> &vis,vector<int>adj[] ){
                            queue<int> q;
                            unordered_map<int,int> part;
                            vis[i]=true;
                            part[i]=-1;
                            q.push(i);
                            while(q.empty()){
                                int cur=q.front();
                                q.pop();
                                for(auto it:adj[cur]){
                                if(vis[it]==true and part[cur]!=it){
                                    return true;
                                }
                                else if(!vis[it]){
                                    q.push(it);
                                    vis[it]=true;
                                    part[it]=cur;
                                }
                            }
                            }
                            return false;
                        }
                            bool isCycle(int V, vector<int> adj[]) {
                                // Code here
                                //Dection of cycle using the BFS way 
                                unordered_map<int,bool> vis;
                                unordered_map<int,list<int>> mp;
                               //to handle the dosconneced componants
                               for(int i=0;i<V;i++){
                                   if(vis[i]==0){
                                       if(iscyclic(i,vis,adj)){
                                           return true;
                                       }
                                   }

                               }
                                return false;
                            }
             
             
             //Approch 2 this is doing by the DFS approach 
               This is also same as that of DFS and just one add up is if the visited is true for a node and it's parent is not
                equal to it's current node than the cycle is present in the graph
                    //Solution 
                      bool detectdfs(vector<int> adj[],int vis[] ,int i,int part){
                                vis[i]=1;
                                for(auto it:adj[i]){
                                    if(!vis[it]){
                                        if(detectdfs(adj,vis,it,i)){
                                            return true;
                                        }
                                    }
                                    else if(it!=part) {
                                        // this means that cycle is present 
                                        return true;
                                    }
                                }
                                return false;
                            }

                          public:
                            bool isCycle(int V, vector<int> adj[]) {
                                int vis[V] = {0};
                                for(int i = 0 ; i < V ; i++) {
                                    if(vis[i] == 0) {
                                        if(detectdfs(adj , vis , i,-1)) return true;
                                    }
                                }
                                return false;
                            }


Q5: Detect cycle in a directed graph
    //Approches 
       //Approch 1 this is doing by the DFS approach 
               This is also same as that of DFS and just one add up is if the visited is true for a node and it's parent is
                equal to it's current node than the cycle is present in the graph
                    //Solution 
                      bool checkcycle(int i, unordered_map<int,bool> &vis,unordered_map<int,bool> &dfscheck,vector<int> adj[]){
                                vis[i]=true;
                                dfscheck[i]=true;
                                for(auto it:adj[i]){
                                    if(!vis[it]){
                                        if(checkcycle(it,vis,dfscheck,adj)){
                                            return true;
                                        }
                                    }
                                    else if(dfscheck[it]) {
                                       return true;    
                                    }
                                }
                                dfscheck[i]=false;
                                return false;
                            }
                            bool isCyclic(int V, vector<int> adj[]) {
                                // code here
                                //call dfs through for all componants
                                unordered_map<int,bool> vis;
                                unordered_map<int,bool> dfsvis;

                                for(int i=0;i<V;i++){
                                    if(!vis[i]){
                                        if(checkcycle(i,vis,dfsvis,adj)){
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            }
            
            //App2 this is doing by the BFS approach 
                  we can also use the topolgical sort if the topological sort is return the sorted graph that means that the cycle is prsent in the graph 
                  So we use the kahn's algo to find this 
            //Solution 
                 

Q6: Topological sort  :- this sorting technique is onliy applied in the directed graph and also in the graph there is no cycle is present;
  //Approches 
    //App1: By using the DFS
             In this we have to call the all the neighbour of the particular node and mark all of them visited 
             And if there is condition where we dont move further than we have to store that node into the stack and that's how your soritng is complete
             
         //Solutions
             void topological(unordered_map<int,bool> &vis,int i,vector<int> adj[],stack<int> &s){
                            vis[i]=true;
                            for(auto it:adj[i]){
                                if(!vis[it]){
                                    vis[it]=true;
                                    topological(vis,it,adj,s);
                                }
                            }
                            s.push(i);
                        }
                        vector<int> topoSort(int V, vector<int> adj[]) 
                        {
                            // code here
                            //Main calling topological function for all componanas in the graph 
                            unordered_map<int,bool> vis;
                            stack<int> s;
                            for(int i=0;i<V;i++){
                                if(!vis[i]){
                                    topological(vis,i,adj,s);
                                }
                            }
                            vector<int> ans;
                            while(!s.empty()){
                                ans.push_back(s.top());
                                s.pop();
                            }
                            return ans;
                        }
                        
                        
        //App2 Using the BFS or Kahn's Algorithim
              In this have to use the conscept of indegree not the visited one in which we have to push the node into the answere vector whose indegree is 0 
              and firstly we have to push the node into the queue and than the answer vector
              
              //Solution
                  	vector<int> topoSort(int V, vector<int> adj[]) 
                                {   //This is using the kahn's alogrithim
                                    // code here
                                    //find the all the node's indegree 
                                    vector<int> indegree(V,0);
                                    for(int i=0;i<V;i++){
                                        for(auto j:adj[i]){
                                            indegree[j]++;
                                        }
                                    }
                                    //0 degree walo loi push karo
                                    queue<int> q;
                                    for(int i=0;i<V;i++){
                                        if(indegree[i] ==0){
                                            q.push(i);
                                        }
                                    }

                                    //Now appling the bfs algorithim 
                                    vector<int> ans;
                                    while( !q.empty()){
                                        auto cur = q.front();
                                        q.pop();

                                    //store the ans
                                    ans.push_back(cur);

                                    for(auto &it:adj[cur]){
                                        indegree[it]--;
                                        if(indegree[it]==0){
                                            q.push(it);
                                        }
                                    }
                                }
                                    return ans;
                                }
               
       
       
       
       
       
       
