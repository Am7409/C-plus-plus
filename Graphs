This is type of Data Strcuter or a combination of edges and nodes .

Q1 Implemantion of graph in the adjecny list form

        //Solution
          #include <bits/stdc++.h>
          using namespace std;

          class graph{
            public: 
             unordered_map<int,list<int>> mp;
            void insertEgde(int u,int v, bool direction){
                //If Direction = 0 -> undirected
                // If Deriection = 1 -> undirected
                mp[u].push_back(v);
                if(direction==0){
                    mp[v].push_back(u);
                }
            }

            void printAdjecylist(){
                for(auto it:mp){
                    cout<<it.first <<" : ";
                    for(auto i:it.second){
                        cout<<i <<", ";
                    }
                    cout<<endl;
                }
            }

          };
          int main() {
            int n,m;
            cout<<"Enter the number of Nodes : ";
            cin>>n;
            cout<<"\nEnter the Number of Edges : ";
            cin>>m;
            graph g;
            for(int i=0;i<m;i++){
                int u,v;
                cin>>u>>v;
                g.insertEgde(u,v,0);
            }
            cout<<endl;
            g.printAdjecylist();
            return 0;
          }


Q2: BFS of graph
   //Aproches
     //App1: For this we have to take the queue to store the nodes and its neighbour and a visited map for the replacing the chance of infinte loop between any
              printed node in the ans array;
              Firstly we have to store the first node and than store all it's neighbour in the queue and pop the front element from the queue and store it into the 
              ans vector;
              and also check any neighbour is also there which is in front of the queue;
              
              //Solutins
              
                vector<int> bfsOfGraph(int V, vector<int> adj[]) {
                        // Code here
                        unordered_map<int,bool> vis;
                        vector<int> ans;
                        queue<int> q;
                        q.push(0);
                        vis[0]=true;
                        while(q.size()>0){
                            int cur=q.front();
                            q.pop();
                            ans.push_back(cur);
                            for(auto i:adj[cur]){
                                if(vis[i]==false){
                                q.push(i);
                                    vis[i]=true;
                                }
                            }
                        }
                        return ans;
                    }
