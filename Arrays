//Introductions 
//An array is a collection of similar data elements stored at contiguous memory locations. 
//It is the simplest data structure where each data element can be accessed directly by only using its index number.
// sytax int arr[];

//Q1: Write a program to reverse an array or string
    //Approches: 
      //App1: 1) Initialize start and end indexes as start = 0, end = n-1   2) In a loop, swap arr[start] with arr[end] and change start and end as follows :  start = start +1, end = end â€“ 1
          //solutions : 
          #include <iostream>
          using namespace std;
          int main() {
              // Write C++ code here
                  int arr[] = {1, 2, 3, 4, 5, 6};
                  for(int i=0;i<(6/2)+1;i++){
                      int temp=arr[i];
                      arr[i]=arr[5-i];
                      arr[5-i]=temp;
                  }
                   for (int i = 0; i < 6; i++)
                   cout << arr[i] << " ";

              return 0;
          }
          
          
 //Q2: Maximum and minimum of an array using minimum number of comparisons
     //Approches:
        //App1: By using the divide and conquern technique 
          // sloutions 
              #include<iostream>
              using namespace std;
              struct Pair
              {
                int min;
                int max;
              };

              Pair getMinMax(int arr[], int n)
              {
                struct Pair minmax;	
                int i;
                if (n == 1)
                {
                  minmax.max = arr[0];
                  minmax.min = arr[0];	
                  return minmax;
                }
                if (arr[0] > arr[1])
                {
                  minmax.max = arr[0];
                  minmax.min = arr[1];
                }
                else
                {
                  minmax.max = arr[1];
                  minmax.min = arr[0];
                }
                for(i = 2; i < n; i++)
                {
                  if (arr[i] > minmax.max)	
                    minmax.max = arr[i];

                  else if (arr[i] < minmax.min)	
                    minmax.min = arr[i];
                }
                return minmax;
              }
              int main()
              {
                int arr[] = { 1000, 11, 445,1, 330, 3000 };
                struct Pair minmax = getMinMax(arr, 6);
                cout << "Minimum element is "<< minmax.min << endl;
                cout << "Maximum element is "<< minmax.max;	
                return 0;
              }


//Q3: Sort an array of 0s, 1s and 2s
   //Approches:
      // App1: just we havw to count the number of zero's , one's and two's and than just to update it by given counts of the numbers 
         //sloutions
              #include <iostream>
              using namespace std;
              int main() {
                      int arr[] = {1, 0,2,2,1,1,0}; 
                      int one=0,zero=0,two=0;
                      for(int i=0;i<7;i++){
                          if(arr[i]==0){
                              zero++;
                          }
                         if(arr[i]== 1){
                             one++;
                         }
                         if(arr[i]==2){
                             two++;
                         }
                      }
                       for (int i = 0; i < zero; i++){
                           arr[i]=0;
                       }
                        for (int i = zero; i <(zero+one) ; i++){
                            arr[i]=1;
                        }
                       for (int i = (zero+one); i < 7; i++)
                          arr[i]=2;
                       for (int i = 0; i < 7; i++)
                       cout << arr[i] << " ";

                  return 0;
              }


//Q4.  Contains Duplicate
   //Approches: 
      //App1: In this first approche is that if you just sort the array and comapiar the ajdcent elements in the arrays if the adjcent elements are same than return true otherwise fasle;
      // App2: Using unordered mapping is also useful for the sluotions of this problem
      //App3: By using the sets in this approche if the size of the set is same as the size of the arrays than return false otherwise true; for example 
         //Sloutions
           // Online C++ compiler to run C++ program online
                #include <bits/stdc++.h>
                using namespace std;
                int  main() {
                    // Write C++ code here
                        vector<int> nums = {1, 0,2,2,1,1,0}; 
                          unordered_set<int> s;
                        for(int i = 0; i < nums.size(); i++)
                            s.insert(nums[i]);
                        if(s.size() != nums.size())
                            cout<<true;
                        else
                            cout<< false;
                    return 0;
                }


//Q5. Move all negative numbers to beginning and positive to end with constant extra space
    //Approches
      //App1: Just to sort it by merge, quick, heap, radix methods 
      //App2: or to let the two arrays one for the negative and other for the positive store the numbers as acccording than merge them because the order of the elements is not matters in this.


//Q6. Union of two arrays
    //Approches: 
       //App1: Just inseert all the elements into the sets 
          //Sloutions 
            #include <bits/stdc++.h>
            using namespace std;
            int main() {
                 int a[]={1, 2, 3, 4, 5};
                 int b[]={1,2,3};
                 set<int> s;
                 for(int i=0;i<5;i++){
                     s.insert(a[i]);
                 }
                 for(int j=0;j<3;j++){
                     s.insert(b[j]);
                 }
                  for(auto str:s){
                     cout<<str<<" ";
                 }
                 cout<<endl;
                 cout<<s.size()<<endl;
                return 0; }


//Q7. Cyclically rotate an array by one from the back side 
   //Approches 
      //App1. Copy the last element into the temp and than copy the rest elements into the other array and than insert the temp array into the new array
          //Solutions
                #include <bits/stdc++.h>
                using namespace std;
                int main() {
                     int a[]={1, 2, 3, 4, 5};
                     int temp=a[4];
                     int b[5];
                     b[0]=temp; 
                     int k=0;
                     for(int i=1;i<5;i++){
                         b[i]=a[k++];
                     }
                     for(int i=0;i<5;i++){
                         cout<<b[i]<<" ";
                     }
                    return 0;
                }
        //App2. By using the simple loop in the reverse order to print the right answer
           //Solutions
                 #include <bits/stdc++.h>
                using namespace std;
                int main() {
                     int a[]={1, 2, 3, 4, 5};
                     for(int i=5-1;i>0;i--){
                         swap(a[i],a[i-1]);
                     }
                     for(int i=0;i<5;i++){
                         cout<<a[i]<<" ";
                     }
                    return 0;
                }


//Q8:Find the maximum sum of the sumarrays in the given array (Kadane's Algorithm)
    //Approches 
        //App1: In this we to find out the max sum of sub array by using this we have to triverse it and check that the maxsum is graeter than the currentsum only. 
            //Solutions 
            #include <bits/stdc++.h>
            using namespace std;
            int main() {
                 int a[]={-4,6,-3,4,-1};
                 int sum=0;
                 int maxsum=INT_MIN;
                 for(int i=0;i<5;i++){
                     sum=max(sum+a[i],a[i]);
                     maxsum=max(sum,maxsum);
                 }
                cout<<maxsum<<endl;
                return 0;
            }


//Q9. Minimum number of jumps    (Given an array of N integers arr[] where each element represents the max length of the jump that can be made forward from that element. 
                                  Find the minimum number of jumps to reach the end of the array (starting from the first element). If an element is 0, then you cannot
                                  move through that element.)
     //Approches 
        //App 1: For this we have to triverse the elements by using the three variables jumps,maxreach, steps : the algo is as follows
                // Algorithim 
                  jumps-=1
                  maxreach=a[0]
                  steps[0]
                  for i=1 to n-1
                     if(n-1==i)
                        return jump
                     maxreach= max(maxreach,a[i]+i)
                        steps--;
                       if(steps==0)
                         jumps++;
                         steps=maxreach-i;
                                     //Solutions
                                      #include <bits/stdc++.h>
                                        using namespace std;
                                        int main() {
                                             int a[]= {1, 4, 3, 2, 6, 7};
                                             int n=11;
                                             if(n<=1){
                                                 cout<<0;
                                             }
                                             if(a[0]==0){
                                                 cout<<-1;
                                             }
                                             int steps=a[0];
                                             int maxsteps=a[0];
                                             int jumps=1;
                                             for(int i=1;i<n;i++){
                                                 if(i==n-1){
                                                    return jumps;
                                                 }
                                                 maxsteps=max(maxsteps,i+a[i]);
                                                    steps--;
                                                    if(steps==0){
                                                        jumps++;
                                                        if(i>=maxsteps){
                                                        return -1;
                                                    }
                                                        steps=maxsteps-i;
                                                    }

                                             }
                                            return 0;
                                        }


//Q10: Next Permutation (The next permutation of an array of integers is the next lexicographically greater permutation of its integer. 
                         More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next 
                         permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must 
                         be rearranged as the lowest possible order (i.e., sorted in ascending order).
                            For example, the next permutation of arr = [1,2,3] is [1,3,2].
                            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].
                            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.
           //Approches
              //App1: 
                  //Solutions 
                   
              
              
              
              
              
              
              
              
              
