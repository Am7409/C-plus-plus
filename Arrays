//Introductions 
//An array is a collection of similar data elements stored at contiguous memory locations. 
//It is the simplest data structure where each data element can be accessed directly by only using its index number.
// sytax int arr[];

//Q1: Write a program to reverse an array or string
    //Approches: 
      //App1: 1) Initialize start and end indexes as start = 0, end = n-1   2) In a loop, swap arr[start] with arr[end] and change start and end as follows :  start = start +1, end = end – 1
          //solutions : 
          #include <iostream>
          using namespace std;
          int main() {
              // Write C++ code here
                  int arr[] = {1, 2, 3, 4, 5, 6};
                  for(int i=0;i<(6/2)+1;i++){
                      int temp=arr[i];
                      arr[i]=arr[5-i];
                      arr[5-i]=temp;
                  }
                   for (int i = 0; i < 6; i++)
                   cout << arr[i] << " ";

              return 0;
          }
          
          
 //Q2: Maximum and minimum of an array using minimum number of comparisons
     //Approches:
        //App1: By using the divide and conquern technique 
          // sloutions 
              #include<iostream>
              using namespace std;
              struct Pair
              {
                int min;
                int max;
              };

              Pair getMinMax(int arr[], int n)
              {
                struct Pair minmax;	
                int i;
                if (n == 1)
                {
                  minmax.max = arr[0];
                  minmax.min = arr[0];	
                  return minmax;
                }
                if (arr[0] > arr[1])
                {
                  minmax.max = arr[0];
                  minmax.min = arr[1];
                }
                else
                {
                  minmax.max = arr[1];
                  minmax.min = arr[0];
                }
                for(i = 2; i < n; i++)
                {
                  if (arr[i] > minmax.max)	
                    minmax.max = arr[i];

                  else if (arr[i] < minmax.min)	
                    minmax.min = arr[i];
                }
                return minmax;
              }
              int main()
              {
                int arr[] = { 1000, 11, 445,1, 330, 3000 };
                struct Pair minmax = getMinMax(arr, 6);
                cout << "Minimum element is "<< minmax.min << endl;
                cout << "Maximum element is "<< minmax.max;	
                return 0;
              }


//Q3: Sort an array of 0s, 1s and 2s
   //Approches:
      // App1: just we havw to count the number of zero's , one's and two's and than just to update it by given counts of the numbers 
         //sloutions
              #include <iostream>
              using namespace std;
              int main() {
                      int arr[] = {1, 0,2,2,1,1,0}; 
                      int one=0,zero=0,two=0;
                      for(int i=0;i<7;i++){
                          if(arr[i]==0){
                              zero++;
                          }
                         if(arr[i]== 1){
                             one++;
                         }
                         if(arr[i]==2){
                             two++;
                         }
                      }
                       for (int i = 0; i < zero; i++){
                           arr[i]=0;
                       }
                        for (int i = zero; i <(zero+one) ; i++){
                            arr[i]=1;
                        }
                       for (int i = (zero+one); i < 7; i++)
                          arr[i]=2;
                       for (int i = 0; i < 7; i++)
                       cout << arr[i] << " ";

                  return 0;
              }


//Q4.  Contains Duplicate
   //Approches: 
      //App1: In this first approche is that if you just sort the array and comapiar the ajdcent elements in the arrays if the adjcent elements are same than return true otherwise fasle;
      // App2: Using unordered mapping is also useful for the sluotions of this problem
      //App3: By using the sets in this approche if the size of the set is same as the size of the arrays than return false otherwise true; for example 
         //Sloutions
           // Online C++ compiler to run C++ program online
                #include <bits/stdc++.h>
                using namespace std;
                int  main() {
                    // Write C++ code here
                        vector<int> nums = {1, 0,2,2,1,1,0}; 
                          unordered_set<int> s;
                        for(int i = 0; i < nums.size(); i++)
                            s.insert(nums[i]);
                        if(s.size() != nums.size())
                            cout<<true;
                        else
                            cout<< false;
                    return 0;
                }


//Q5. Move all negative numbers to beginning and positive to end with constant extra space
    //Approches
      //App1: Just to sort it by merge, quick, heap, radix methods 
      //App2: or to let the two arrays one for the negative and other for the positive store the numbers as acccording than merge them because the order of the elements is not matters in this.


//Q6. Union of two arrays
    //Approches: 
       //App1: Just inseert all the elements into the sets 
          //Sloutions 
            #include <bits/stdc++.h>
            using namespace std;
            int main() {
                 int a[]={1, 2, 3, 4, 5};
                 int b[]={1,2,3};
                 set<int> s;
                 for(int i=0;i<5;i++){
                     s.insert(a[i]);
                 }
                 for(int j=0;j<3;j++){
                     s.insert(b[j]);
                 }
                  for(auto str:s){
                     cout<<str<<" ";
                 }
                 cout<<endl;
                 cout<<s.size()<<endl;
                return 0; }


//Q7. Cyclically rotate an array by one from the back side 
   //Approches 
      //App1. Copy the last element into the temp and than copy the rest elements into the other array and than insert the temp array into the new array
          //Solutions
                #include <bits/stdc++.h>
                using namespace std;
                int main() {
                     int a[]={1, 2, 3, 4, 5};
                     int temp=a[4];
                     int b[5];
                     b[0]=temp; 
                     int k=0;
                     for(int i=1;i<5;i++){
                         b[i]=a[k++];
                     }
                     for(int i=0;i<5;i++){
                         cout<<b[i]<<" ";
                     }
                    return 0;
                }
        //App2. By using the simple loop in the reverse order to print the right answer
           //Solutions
                 #include <bits/stdc++.h>
                using namespace std;
                int main() {
                     int a[]={1, 2, 3, 4, 5};
                     for(int i=5-1;i>0;i--){
                         swap(a[i],a[i-1]);
                     }
                     for(int i=0;i<5;i++){
                         cout<<a[i]<<" ";
                     }
                    return 0;
                }


//Q8:Find the maximum sum of the sumarrays in the given array (Kadane's Algorithm)
    //Approches 
        //App1: In this we to find out the max sum of sub array by using this we have to triverse it and check that the maxsum is graeter than the currentsum only. 
            //Solutions 
            #include <bits/stdc++.h>
            using namespace std;
            int main() {
                 int a[]={-4,6,-3,4,-1};
                 int sum=0;
                 int maxsum=INT_MIN;
                 for(int i=0;i<5;i++){
                     sum=max(sum+a[i],a[i]);
                     maxsum=max(sum,maxsum);
                 }
                cout<<maxsum<<endl;
                return 0;
            }


//Q9. Minimum number of jumps    (Given an array of N integers arr[] where each element represents the max length of the jump that can be made forward from that element. 
                                  Find the minimum number of jumps to reach the end of the array (starting from the first element). If an element is 0, then you cannot
                                  move through that element.)
     //Approches 
        //App 1: For this we have to triverse the elements by using the three variables jumps,maxreach, steps : the algo is as follows
                // Algorithim 
                  jumps-=1
                  maxreach=a[0]
                  steps[0]
                  for i=1 to n-1
                     if(n-1==i)
                        return jump
                     maxreach= max(maxreach,a[i]+i)
                        steps--;
                       if(steps==0)
                         jumps++;
                         steps=maxreach-i;
                                     //Solutions
                                      #include <bits/stdc++.h>
                                        using namespace std;
                                        int main() {
                                             int a[]= {1, 4, 3, 2, 6, 7};
                                             int n=11;
                                             if(n<=1){
                                                 cout<<0;
                                             }
                                             if(a[0]==0){
                                                 cout<<-1;
                                             }
                                             int steps=a[0];
                                             int maxsteps=a[0];
                                             int jumps=1;
                                             for(int i=1;i<n;i++){
                                                 if(i==n-1){
                                                    return jumps;
                                                 }
                                                 maxsteps=max(maxsteps,i+a[i]);
                                                    steps--;
                                                    if(steps==0){
                                                        jumps++;
                                                        if(i>=maxsteps){
                                                        return -1;
                                                    }
                                                        steps=maxsteps-i;
                                                    }

                                             }
                                            return 0;
                                        }


//Q10: Next Permutation (The next permutation of an array of integers is the next lexicographically greater permutation of its integer. 
                         More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next 
                         permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must 
                         be rearranged as the lowest possible order (i.e., sorted in ascending order).
                            For example, the next permutation of arr = [1,2,3] is [1,3,2].
                            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].
                            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.
           //Approches
              //App1: 
                  //Solutions 
                   
              
              
//Q11.  Best Time to Buy and Sell Stock  (You are given an array prices where prices[i] is the price of a given stock on the ith day.
                                          You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
                                          Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.)          
           //Approches
              //App1:   The idea is quite simple, we’ve to find the max profit by selling the stocks.
                        We took 2 int variables: mn (to store the minimum till a particular date) & ans.
                        Run a for loop and in every time check for the minimum value till that iteration and store it in mn ~min(mn, prices[i]).
                        Also, find the ans with max(ans, prices[i]-mn).
                        Time complexity: O(n).
                 //Solutions 
                     int maxProfit(vector<int>& prices) {
                     int n= prices.size();
                    int mn= INT_MAX;
                    int ans=0;

                    for(int i=0; i<n; i++){
                        mn = min(mn, prices[i]);
                        ans = max(ans, prices[i]-mn);
                    }
                    return ans;
                }
 
 
//Q12: Count pairs with given sum 
    //Approches 
       //App1: 
          //Sloutions  Simple approach is just run one loop from 0 to n and other from i+1 to n and check the condition of the given number 
            #include <bits/stdc++.h>
            using namespace std;
            int main() {
            int arr[] = {1, 5, 7, 1};
            int n=4; int k=6; int c=0;
              for(int i=0;i<n;i++){
                  for(int j=i+1;j<n;j++){
                      if(arr[i]+arr[j]==k){
                          c++;
                      }}}
                  cout<<c<<endl;
                return 0;
            }

              
 //Q13: Common elements   (Given three arrays sorted in increasing order. Find the elements that are common in all three arrays.
                           Note: can you take care of the duplicates without using any additional Data Structure?)
     //Approches
        //App1: By using the three loops and just check the conditions 
         //Sloutions 
           #include <bits/stdc++.h>
            using namespace std;
            int main() {
            int n1 = 6,A[] = {1, 5, 10, 20, 40, 80};
            int n2 = 5, B[] = {6, 7, 20, 80, 100};
            int n3 = 8, C []= {3, 4, 15, 20, 30, 70, 80, 120};
                 set<int> s;
                 for(int i=0;i<n1;i++){
                     for(int j=0;j<n2;j++){
                         for(int k=0;k<n3;k++){
                             if(A[i]-B[j]==0 and C[k]-A[i]==0 and B[j]-C[k]==0){
                                 s.insert(C[k]);
                             }
                         }
                     }
                 }
                 for(auto it:s){
                     cout<<it<<" ";
                 }
                return 0;
            }
            
            
//Q14: Rearrange array in alternating positive & negative items with O(1) extra space
    //Approches 
      //App1:The brute force approach is to divide the all the positive nuber and negative in the differnt arrays and than merge accoeding to the ith place i.e. at the 
             odd palce psotive and at odd place the negative number.
        //Sloutions 
      //App2: In this approach we have to use two pointer in which first is start from the -1 and other one is from the "n" in the left side we have to store the positive 
              number and the right side the negative numbers using the while loop. 
              After this we have to take the new variable which starts from the "0" and than apply the while loop in this we have to swap the ith value to the kth value becuzz
                the ith is at the first negative number and the kth is at the largest positive number and increase the i with one and k by 2.
        //Solutions:
            #include <bits/stdc++.h>
            using namespace std;
            void rearrange(int a[],int n){
                int i=0; int j=n;
                while(i<j){
                    while(i<=n-1 and a[i]>0)
                        i++;
                    while(j>=0 and a[j]<0)
                        j--;
                        if(i<j)
                        swap(a[i],a[j]);
                }
                if(i==0 or i==n-1)
                  return;
               int k=0;
               while(k<n and i<n){
                   swap(a[k],a[i]);
                   i++;
                   k=k+2;
               }

            }
            void print(int a[],int n){
                for(int i=0;i<n;i++){
                    cout<<a[i]<<" ";
                }
            }
            int main() {
                // Write C++ code here
                int a[]={1, 2, 3, -4, -1, 4};
                int n=6;
                print(a,n);
                rearrange(a,n);
                cout<<endl;
                 print(a,n);
                return 0;
            }
              
              
//Q15: Subarray with 0 sum
    //Approches
      //App1: This is the burt force method by using the two loops for the finding the array
         //Solutions
         #include <bits/stdc++.h>
            using namespace std;
            int main() {
                // Write C++ code here
                int a[]={4, 2, -3, 1, 6};
                int n=5;
                int sum=0;
                for(int i=0;i<n;i++){
                   int sum=0;
                   for(int j=i;j<n;j++){
                       sum+=a[j];
                       if(sum==0){
                           cout<<"YES"<<endl;
                           break;
                       }
                   }
                }
                return 0;
            }
            
            
//Q16:             
            
            
            
