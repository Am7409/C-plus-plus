//Introductions 
//An array is a collection of similar data elements stored at contiguous memory locations. 
//It is the simplest data structure where each data element can be accessed directly by only using its index number.
// sytax int arr[];

//Q1: Write a program to reverse an array or string
    //Approches: 
      //App1: 1) Initialize start and end indexes as start = 0, end = n-1   2) In a loop, swap arr[start] with arr[end] and change start and end as follows :  start = start +1, end = end â€“ 1
          //solutions : 
          #include <iostream>
          using namespace std;
          int main() {
              // Write C++ code here
                  int arr[] = {1, 2, 3, 4, 5, 6};
                  for(int i=0;i<(6/2)+1;i++){
                      int temp=arr[i];
                      arr[i]=arr[5-i];
                      arr[5-i]=temp;
                  }
                   for (int i = 0; i < 6; i++)
                   cout << arr[i] << " ";

              return 0;
          }
          
          
 //Q2: Maximum and minimum of an array using minimum number of comparisons
     //Approches:
        //App1: By using the divide and conquern technique 
          // sloutions 
              #include<iostream>
              using namespace std;
              struct Pair
              {
                int min;
                int max;
              };

              Pair getMinMax(int arr[], int n)
              {
                struct Pair minmax;	
                int i;
                if (n == 1)
                {
                  minmax.max = arr[0];
                  minmax.min = arr[0];	
                  return minmax;
                }
                if (arr[0] > arr[1])
                {
                  minmax.max = arr[0];
                  minmax.min = arr[1];
                }
                else
                {
                  minmax.max = arr[1];
                  minmax.min = arr[0];
                }
                for(i = 2; i < n; i++)
                {
                  if (arr[i] > minmax.max)	
                    minmax.max = arr[i];

                  else if (arr[i] < minmax.min)	
                    minmax.min = arr[i];
                }
                return minmax;
              }
              int main()
              {
                int arr[] = { 1000, 11, 445,1, 330, 3000 };
                struct Pair minmax = getMinMax(arr, 6);
                cout << "Minimum element is "<< minmax.min << endl;
                cout << "Maximum element is "<< minmax.max;	
                return 0;
              }


//Q3: Sort an array of 0s, 1s and 2s
   //Approches:
      // App1: just we havw to count the number of zero's , one's and two's and than just to update it by given counts of the numbers 
         //sloutions
              #include <iostream>
              using namespace std;
              int main() {
                      int arr[] = {1, 0,2,2,1,1,0}; 
                      int one=0,zero=0,two=0;
                      for(int i=0;i<7;i++){
                          if(arr[i]==0){
                              zero++;
                          }
                         if(arr[i]== 1){
                             one++;
                         }
                         if(arr[i]==2){
                             two++;
                         }
                      }
                       for (int i = 0; i < zero; i++){
                           arr[i]=0;
                       }
                        for (int i = zero; i <(zero+one) ; i++){
                            arr[i]=1;
                        }
                       for (int i = (zero+one); i < 7; i++)
                          arr[i]=2;
                       for (int i = 0; i < 7; i++)
                       cout << arr[i] << " ";

                  return 0;
              }


//Q4.  Contains Duplicate
   //Approches: 
      //App1: In this first approche is that if you just sort the array and comapiar the ajdcent elements in the arrays if the adjcent elements are same than return true otherwise fasle;
      // App2: Using unordered mapping is also useful for the sluotions of this problem
      //App3: By using the sets in this approche if the size of the set is same as the size of the arrays than return false otherwise true; for example 
         //Sloutions
           // Online C++ compiler to run C++ program online
                #include <bits/stdc++.h>
                using namespace std;
                int  main() {
                    // Write C++ code here
                        vector<int> nums = {1, 0,2,2,1,1,0}; 
                          unordered_set<int> s;
                        for(int i = 0; i < nums.size(); i++)
                            s.insert(nums[i]);
                        if(s.size() != nums.size())
                            cout<<true;
                        else
                            cout<< false;
                    return 0;
                }


//Q5. Move all negative numbers to beginning and positive to end with constant extra space
    //Approches
      //App1: Just to sort it by merge, quick, heap, radix methods 
      //App2: or to let the two arrays one for the negative and other for the positive store the numbers as acccording than merge them because the order of the elements is not matters in this.


//Q6. Union of two arrays
    //Approches: 
        //App1: By using the mapping method and just store the first value of mapp in the vector.
       //App2: Just inseert all the elements into the sets 
          //Sloutions 
            #include <bits/stdc++.h>
            using namespace std;
            int main() {
                 int a[]={1, 2, 3, 4, 5};
                 int b[]={1,2,3};
                 set<int> s;
                 for(int i=0;i<5;i++){
                     s.insert(a[i]);
                 }
                 for(int j=0;j<3;j++){
                     s.insert(b[j]);
                 }
                  for(auto str:s){
                     cout<<str<<" ";
                 }
                 cout<<endl;
                 cout<<s.size()<<endl;
                return 0; }


//Q7. Cyclically rotate an array by one from the back side 
   //Approches 
      //App1. Copy the last element into the temp and than copy the rest elements into the other array and than insert the temp array into the new array
          //Solutions
                #include <bits/stdc++.h>
                using namespace std;
                int main() {
                     int a[]={1, 2, 3, 4, 5};
                     int temp=a[4];
                     int b[5];         //O(n)  space complixity
                     b[0]=temp; 
                     int k=0;
                     for(int i=1;i<5;i++){
                         b[i]=a[k++];
                     }
                     for(int i=0;i<5;i++){
                         cout<<b[i]<<" ";
                     }
                    return 0;
                }
        //App2. By using the simple loop in the reverse order to print the right answer by using the swapping. 
           //Solutions
                 #include <bits/stdc++.h>
                using namespace std;
                int main() {
                     int a[]={1, 2, 3, 4, 5};
                     for(int i=5-1;i>0;i--){
                         swap(a[i],a[i-1]);      //O(1)      space complixity
                     }
                     for(int i=0;i<5;i++){
                         cout<<a[i]<<" ";
                     }
                    return 0;
                }


//Q8:Find the maximum sum of the sumarrays in the given array (Kadane's Algorithm)
    //Approches 
        //App1: In this we to find out the max sum of sub array by using this we have to triverse it and check that the maxsum is graeter than the currentsum only. 
            //Solutions 
            #include <bits/stdc++.h>
            using namespace std;
            int main() {
                 int a[]={-4,6,-3,4,-1};
                 int sum=0;    //current sum 
                 int maxsum=INT_MIN;   // maximun sum when current sum is greater than the max sum 
                 for(int i=0;i<5;i++){
                     sum=max(sum+a[i],a[i]);
                     maxsum=max(sum,maxsum);
                 }
                cout<<maxsum<<endl;
                return 0;
            }


//Q9. Minimum number of jumps    (Given an array of N integers arr[] where each element represents the max length of the jump that can be made forward from that element. 
                                  Find the minimum number of jumps to reach the end of the array (starting from the first element). If an element is 0, then you cannot
                                  move through that element.)
     //Approches 
        //App 1: For this we have to triverse the elements by using the three variables jumps,maxreach, steps : the algo is as follows
                // Algorithim 
                  jumps=1;
                  maxreach=a[0]
                  steps[0]
                  for i=1 to n-1
                     if(n-1==i)
                        return jump
                     maxreach= max(maxreach,a[i]+i)
                        steps--;
                       if(steps==0)
                         jumps++;
                         steps=maxreach-i;
                                     //Solutions
                                      #include <bits/stdc++.h>
                                        using namespace std;
                                        int main() {
                                             int a[]= {1, 4, 3, 2, 6, 7};
                                             int n=11;
                                             if(n<=1){
                                                 cout<<0;
                                             }
                                             if(a[0]==0){         
                                                 cout<<-1;
                                             }
                                             int steps=a[0];
                                             int maxsteps=a[0];
                                             int jumps=1;
                                             for(int i=1;i<n;i++){
                                                 if(i==n-1){               // if the ith element is 0 then can't jump further
                                                    return jumps;
                                                 }
                                                 maxsteps=max(maxsteps,i+a[i]);        //find the maximum steps that we can can go in the given array
                                                    steps--;
                                                    if(steps==0){
                                                        jumps++;                //we can only jump if we walk enough steps of the given value 
                                                        if(i>=maxsteps){
                                                        return -1;
                                                    }
                                                        steps=maxsteps-i;         // formulafor finding the steps 
                                                    }

                                             }
                                            return 0;
                                        }


//Q10: Next Permutation (The next permutation of an array of integers is the next lexicographically greater permutation of its integer. 
                         More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next 
                         permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must 
                         be rearranged as the lowest possible order (i.e., sorted in ascending order).
                            For example, the next permutation of arr = [1,2,3] is [1,3,2].
                            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].
                            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.
           //Approches
              //App1: 
                  //Solutions 
                   
              
              
//Q11.  Best Time to Buy and Sell Stock  (You are given an array prices where prices[i] is the price of a given stock on the ith day.
                                          You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
                                          Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.)          
           //Approches
              //App1:   The idea is quite simple, weâ€™ve to find the max profit by selling the stocks.
                        We took 2 int variables: mn (to store the minimum till a particular date) & ans.
                        Run a for loop and in every time check for the minimum value till that iteration and store it in mn ~min(mn, prices[i]).
                        Also, find the ans with max(ans, prices[i]-mn).
                        Time complexity: O(n).
                 //Solutions 
                     int maxProfit(vector<int>& prices) {
                     int n= prices.size();
                    int mn= INT_MAX;
                    int ans=0;

                    for(int i=0; i<n; i++){
                        mn = min(mn, prices[i]);
                        ans = max(ans, prices[i]-mn);
                    }
                    return ans;
                }
 
 
//Q12: Count pairs with given sum 
    //Approches 
       //App1: 
          //Sloutions  Simple approach is just run one loop from 0 to n and other from i+1 to n and check the condition of the given number 
            #include <bits/stdc++.h>
            using namespace std;
            int main() {
            int arr[] = {1, 5, 7, 1};
            int n=4; int k=6; int c=0;
              for(int i=0;i<n;i++){
                  for(int j=i+1;j<n;j++){
                      if(arr[i]+arr[j]==k){
                          c++;
                      }}}
                  cout<<c<<endl;
                return 0;
            }

              
 //Q13: Common elements   (Given three arrays sorted in increasing order. Find the elements that are common in all three arrays.
                           Note: can you take care of the duplicates without using any additional Data Structure?)
     //Approches
        //App1: By using the three loops and just check the conditions 
         //Sloutions 
           #include <bits/stdc++.h>
            using namespace std;
            int main() {
            int n1 = 6,A[] = {1, 5, 10, 20, 40, 80};
            int n2 = 5, B[] = {6, 7, 20, 80, 100};
            int n3 = 8, C []= {3, 4, 15, 20, 30, 70, 80, 120};
                 set<int> s;
                 for(int i=0;i<n1;i++){
                     for(int j=0;j<n2;j++){
                         for(int k=0;k<n3;k++){
                             if(A[i]-B[j]==0 and C[k]-A[i]==0 and B[j]-C[k]==0){
                                 s.insert(C[k]);
                             }
                         }
                     }
                 }
                 for(auto it:s){
                     cout<<it<<" ";
                 }
                return 0;
            }
            
            
//Q14: Rearrange array in alternating positive & negative items with O(1) extra space
    //Approches 
      //App1:The brute force approach is to divide the all the positive nuber and negative in the differnt arrays and than merge accoeding to the ith place i.e. at the 
             odd palce psotive and at odd place the negative number.
        //Sloutions 
      //App2: In this approach we have to use two pointer in which first is start from the -1 and other one is from the "n", in the left side we have to store the positive 
              number and the right side store the negative numbers using the while loop. 
              After this we have to take the new variable which starts from the "0" and than apply the while loop in this we have to swap the ith value to the kth value becuzz
              the ith is at the first negative number and the kth is at the largest positive number and increase the i with one and k by 2.
        //Solutions:
            #include <bits/stdc++.h>
            using namespace std;
            void rearrange(int a[],int n){
                int i=0; int j=n;
                while(i<j){
                    while(i<=n-1 and a[i]>0)
                        i++;
                    while(j>=0 and a[j]<0)
                        j--;
                        if(i<j)
                        swap(a[i],a[j]);
                }
                if(i==0 or i==n-1)
                  return;
               int k=0;
               while(k<n and i<n){
                   swap(a[k],a[i]);
                   i++;
                   k=k+2;
               }

            }
            void print(int a[],int n){
                for(int i=0;i<n;i++){
                    cout<<a[i]<<" ";
                }
            }
            int main() {
                // Write C++ code here
                int a[]={1, 2, 3, -4, -1, 4};
                int n=6;
                print(a,n);
                rearrange(a,n);
                cout<<endl;
                 print(a,n);
                return 0;
            }
              
              
//Q15: Subarray with 0 sum
    //Approches
      //App1: This is the burt force method by using the two loops for the finding the array
         //Solutions
         #include <bits/stdc++.h>
            using namespace std;
            int main() {
                // Write C++ code here
                int a[]={4, 2, -3, 1, 6};
                int n=5;
                int sum=0;
                for(int i=0;i<n;i++){
                   int sum=0;
                   for(int j=i;j<n;j++){
                       sum+=a[j];
                       if(sum==0){
                           cout<<"YES"<<endl;
                           break;
                       }
                   }
                }
                return 0;
            }
            
            
//Q16: Factorials of large numbers and return the answer in the vectore 
     //Approches
        //App1: In this we have to first find the factorial and insert the  answer into the vector for the larger value 
           //Sloutions 
           #include <bits/stdc++.h>
            using namespace std;
            int main() {
                 int  n=20;
                long long int fact=1;
                vector<int> v;
                for(int i=1;i<=n;i++){
                    fact=fact*i;
                }
                int mes=1;
                while(fact!=0){
                    v.push_back(fact%10);
                    fact/=10;
                }
                reverse(v.begin(),v.end());
                for(int i=0;i<v.size();i++){
                    cout<<v[i];
                }
                return 0;
            }
            
            
//Q17: Maximum Product Subarray 
    //Approches 
       //App1: In this we have to use the kadan's algorithim to find the subarray which have the maximum product in O(n) time.
         //Sloutions
          #include <bits/stdc++.h>
            using namespace std;
            int main() {
                 int a[]={2, 0, 4, 5, -1, 0};
                 int n=6;
                 long long mul=INT_MIN,ans=1;
                 for(int i=0;i<n;i++ ){
                     mul=(mul*a[i]);
                     ans=max(mul,ans);
                     if(mul==0)
                        mul=1;
                 }
                 mul=1;
                 for(int i=n-1;i>=0;i-- ){
                     mul=(mul*a[i]);
                     ans=max(mul,ans);
                     if(mul==0)
                        mul=1;
                 }
                 cout<<ans;
                return 0;
            }


Q18: Longest consecutive subsequence
   //Aproches 
     //App1: By using the loop and check the condition of getting the differnce of 1. 
       //Solutions 
         #include <bits/stdc++.h>
            using namespace std;
            int main() {
                 int a[]={1,9,3,10,4,20,2};
                 int n=7;int c=0;
                 sort(a,a+n); int i=1;
                 for(i=0;i<n-1;i++){
                     if(a[i+1]-a[i]==1){
                         c++;
                     }
                 }
                 cout<<c;
                return 0;
            }
    //App2: In this first we insert the array elements in the set and apply the loop and check the condition to find if its previous element is present in the set or not 
            and if present if than the current element is not the starting element of the sequence.
            Now check the condition that for that whose previous element is present in the set, so it may the first element of the sequence and find the sequence of that starting
            element and find the maximum lenght of the array.
      //Solutions:
      #include <bits/stdc++.h>
        using namespace std;
        int main() {
             int a[]={1,9,3,10,4,20,2};
             int n=7;int c=0;
             set<int> s;
             for(int i=0;i<n;i++){
                 s.insert(a[i]);
             }
             for(int i=0;i<n;i++){
                 if(s.find(a[i]-1)!=s.end()){
                     continue;
                 }
                 else{
                     int count=0;
                     int current=a[i];
                     while(s.find(current)!=s.end()){
                         count++;
                         current++;
                     }
                     c=max(c,count);
                 }
             }
             cout<<c;
            return 0;
        }
    
    
//Q19: Given an array of size n and a number k, find all elements that appear more than n/k times
   //Approches 
     //App1: By using the map approche we just have to find the map second to comapre with n/k;
       //Solutions 
          #include <bits/stdc++.h>
            using namespace std;
            int main() {
                 int a[]= {3, 1, 2, 2, 1, 2, 3, 3};
                 int n=8;
                 int k=4;
                 map<int,int> m;
                 for(int i=0;i<n;i++){
                     m[a[i]]++;
                 }
                 int c=n/k;
                 for(auto it:m){
                     if(it.second > c)
                     cout<<it.first<<" ";
                 }
                return 0;
            }
     //App2: 
       //Solutions 
       
       
       
Q20: Maximum profit by buying and selling a share at most twice
   //Approches 
     //App1:  Initialize four variables for taking care of the first buy, first sell, second buy, second sell. Set first buy and second buy as INT_MIN and first and 
              second sell as 0. This is to ensure to get profit from transactions. Iterate through the array and return the second sell as it will store maximum profit.
               we find the first transcations and than the second one.
       //Solutions 
         #include <bits/stdc++.h>
            using namespace std;
            int main() {
                 int a[]={ 2, 30, 15, 10, 8, 25, 80 };
                 int n=7;
                int  first_buy=INT_MIN,first_sell=0,second_buy=INT_MIN,second_sell=0;
                 for(int i=0;i<n;i++){
                     first_buy=max(first_buy,-a[i]);//we set prices to negative, so the calculation of profit will be convenient
                     first_sell=max(first_sell,first_buy+a[i]);
                     second_buy=max(second_buy,first_sell-a[i]);//we can buy the second only after first is sold
                     second_sell=max(second_sell,second_buy+a[i]);
                 }
                 cout<<second_sell;
                return 0;
            }
       
        
//Q21: Array Subset of another array
     //Approches: 
       //App1: we can use the two sets and than the major set we have to find the elements from the major to the minor one. 
         //Solutions
           #include <bits/stdc++.h>
            using namespace std;
            int main() {
              int a[] = {10, 5, 2, 23, 19};
            int b[] = {19, 5, 3};
                int n=5,m=3;
                 set<int> s1,s2;
                 for(int i=0;i<n;i++){
                     s1.insert(a[i]);
                 }
                 for(int j=0;j<m;j++){
                     s2.insert(b[j]);
                 }  int c=0;
                 for(auto it: s2){
                     auto itr=s1.find(it);
                     if(*itr==it){
                         c++;
                     }
                 }
                 cout<<c;
                 if(c==m)
                 cout<<"YES"<<endl;
                 else
                   cout<<"NO"<<endl;
                return 0;
            }   
            
            
//Q22: Triplet Sum in Array
     //Approches
        //App1: The burt force method is to make the three loops and than check the  conditons
        //App2: the most optmize method is to sort the array first and than apply the loop and the make the two variables to one pointing the next index of the main index
                loop and other pointes the last value and than ckeck the condition if stisfied than return true if not check the given sum is greater than reduce the variabel 
                 that starts from the last otherwise increse the variable that starts the next of the main index value. 
          //Solutions
            #include <bits/stdc++.h>
            using namespace std;

            bool triplits(int a[],int n,int s){
                sort(a,a+n);
                int j,k;
                for(int i=0;i<n-2;i++){
                    j=i+1; k=n-1;
                    while(j<k){
                        int sum=a[i]+a[j]+a[k];
                        if(sum==s){
                             return true;
                        }
                        else if(sum<s){
                            j++;
                        }
                        else{
                            k--;
                        }
                    }
                }
                return false;
            }
            int main(){
                bool flag=false;
                int a[]={1, 2, 4,3,6};
                int n=6; int s=10;
                for(int i=0;i<n-2;i++){
                    for(int j=i+1;j<n-1;j++){
                        for(int k=j+1;k<n;k++){
                            if(a[i]+a[j]+a[k]==s){
                                flag=true;
                                break;
                            }
                        }
                    }
                }
                cout<<triplits(a,n,s);
                return 0;
            }
        
        
//Q23: Trapping Rain Water  (Given an array arr[] of N non-negative integers representing the height of blocks. If width of each block is 1, compute how much water 
                           can be trapped between the blocks during the rainy season.)        
      //Approches 
         //App1: In this we have to preprocess the array for this we have to take the two arrays and than first one starts from the left side to comapre the blocks 
                 height and the store the vlaue which has the max value for thath index, and same with the right side started array.
                 And after the comparision the make the formula to find the trapped water in between the bulidings i.e. sum+=(min(b[i],c[i])-a[i]);
           //Solutions: 
            #include <bits/stdc++.h>
            using namespace std;
            int rain_water_trapping(int a[],int n){
                int b[n],c[n];
                b[0]=a[0];
                for(int i=1;i<n;i++){
                    b[i]=max(b[i-1],a[i]);
                }
                c[n-1]=a[n-1];
                for(int i=n-2;i>=0;i--){
                    c[i]=max(c[i+1],a[i]);
                }
                  int sum=0;
                for(int i=0;i<n;i++){
                   sum+=(min(b[i],c[i])-a[i]);
                }
                return sum;
            }
            int main(){
                int a[]={6,9,9};
                int n=3;
               cout<< rain_water_trapping(a,n);
                return 0;
            }
        
        
//Q24:  Chocolate Distribution Problem
    //Approches 
      //App1: In this problem we have to use the two pointer technique first pointer we have to use at the starting of the array and second we have to the i+m-1 place
              iterate if to find the minma of the maximum value in the subarray and the minma vlaue in the subarray.
        //solutions
          #include <bits/stdc++.h>
            using namespace std;
            int main() {
                // Write C++ code here
                 int a[]={3, 4, 1, 9, 56, 7, 9, 12};
                 int n=8,m=5;
                 int minmaa=INT_MAX;
                 sort(a,a+n);
                 for(int i=0;i+m-1<n;i++){
                     minmaa=min(minmaa,a[i+m-1]-a[i]);
                 }
                 cout<<minmaa;
                return 0;
            }
        
        
//Q25: Sliding window approach 
    //Approches 
       //App1:In this method we have given a k which is the size of the window, first we have to sum all the elements of the array upto the size of the window 
              and than find the minimum sum of that sum, and than make a loop to triverse from 1 to n and make condition of sum-a[i-1]+a[k+i-1] so that the window will 
               slide
          //Solutions:
            #include <bits/stdc++.h>
            using namespace std;

            int main()
            {
                int a[]={3,2,6,4,8,2};
                int n=6,m=3; int sum=0;
                int minmaa=INT_MAX;
                for(int i=0;i<m;i++){
                    sum+=a[i];
                }
                minmaa=min(minmaa,sum);
                cout<<minmaa<<" ";
                for(int i=1;i<=n-m;i++){
                    cout<<(minmaa-a[i-1]+a[m+i-1])<<" ";
                }
                //cout<<sum;
                return 0;
            }
            
            
//Q26: Smallest subarray with sum greater than x            
     //Approches
       //App1: For this we have the sliding window algorithim and two pointer approach and than we have two variables both are started with 0 and than first start the 
               end  variable to find the sum of the given varibles and than start the loop of the start varible to find the minimum length of the subarray.
               And at the check the conditoin that the minlength of the subarray is equal to the m+1 if true than no sunarry  is present in the array and false than 
               print the array.
          //Solutions:
            #include <bits/stdc++.h>
            using namespace std;

            int main()
            {
                int a[]={1, 4, 45, 6, 0, 19};
                int n=6,x=51; int sum=0;
                int start=0,end=0,minlen=n+1;
                while(end<n){
                    while(sum<=x and end<n){
                        sum+=a[end++];
                    }
                    while(sum>x and start<n){
                        if(end-start<minlen){
                            minlen=end-start;
                        }
                        sum-=a[start++];
                    }
                }
                if(minlen==n+1)
                   cout<<"Not exist any subarray";
                   else
                    cout<<minlen;
                return 0;
            }
        
        
//Q27: Three way partitioning  (Ducth Algorithim):- This algo is usefull for finding for the partioing of the array.
   //Approches
     //App1:
       ??Solutions:
         #include <bits/stdc++.h>
            using namespace std;

            void partions(int arr[],int n,int a,int b){
                int s=0,i=0,e=n-1;
                while(i<e){
                    if(arr[i]<a){
                        swap(arr[i++],arr[s++]);
                    }
                    else if(arr[i]>b){
                        swap(arr[i],arr[e--]);
                    }
                    else
                        i++;
                }
            }
            int main()
            {
                int arr[]={1, 2,34,3,4};
                int n=5; int a=1,b=2;
                partions(arr,n,a,b);
                for(int i=0;i<n;i++)
                   cout<<arr[i]<<" ";

                return 0;
            }  
            
            
//Q28: Find minimum number of merge operations to make an array palindrome or Minimum number of operations to make the array palindrome          
    //Aproches
      //App1: In this problem we use the two pointer method to solve it. The first pointer is started from the intiale vlaue and other is started from the last index of 
              the array and than check that if the last and first elements are equal or not if true than just move forward and if not than find which number is small
              and than add it to the adjacent value in hope the sum is equal to the larger value.
        //Solution:
          #include <bits/stdc++.h>
            using namespace std;
            int main() {
                // Write C++ code here
                int a[]={1, 4, 5, 1};
                int n=4,i=0,j=n-1;
               int ans=0;
                while(i<j){
                    if(a[i]==a[j]){
                        i++;
                        j--;
                    }
                    else if(a[i]<a[j]){
                        ans++;
                        i++;
                        a[i]+=a[i-1];
                    }
                    else{
                        ans++;
                        j--;
                        a[j]+=a[j+1];
                    }
                }
                cout<<ans;
                return 0;
            }
        

//Q29: Median of two sorted arrays of same size
    //Approches
      //App1:
        //Solution:
            #include <bits/stdc++.h>
            using namespace std;

            /* This function returns
            median of ar1[] and ar2[].
            Assumptions in this function:
            Both ar1[] and ar2[]
            are sorted arrays
            Both have n elements */
            int getMedian(int ar1[],
                        int ar2[], int n)
            {
                int i = 0; /* Current index of
                            i/p array ar1[] */
                int j = 0; /* Current index of
                            i/p array ar2[] */
                int count;
                int m1 = -1, m2 = -1;

                /* Since there are 2n elements,
                median will be average of elements
                at index n-1 and n in the array
                obtained after merging ar1 and ar2 */
                for (count = 0; count <= n; count++)
                {
                    /* Below is to handle case where
                    all elements of ar1[] are
                    smaller than smallest(or first)
                    element of ar2[]*/
                    if (i == n)
                    {
                        m1 = m2;
                        m2 = ar2[0];
                        break;
                    }

                    /*Below is to handle case where
                    all elements of ar2[] are
                    smaller than smallest(or first)
                    element of ar1[]*/
                    else if (j == n)
                    {
                        m1 = m2;
                        m2 = ar1[0];
                        break;
                    }
                    /* equals sign because if two
                    arrays have some common elements */
                    if (ar1[i] <= ar2[j])
                    {
                        /* Store the prev median */
                        m1 = m2;
                        m2 = ar1[i];
                        i++;
                    }
                    else
                    {
                        /* Store the prev median */
                        m1 = m2;
                        m2 = ar2[j];
                        j++;
                    }
                }

                return (m1 + m2)/2;
            }

            // Driver Code
            int main()
            {
                int ar1[] = {1, 12, 15, 26, 38};
                int ar2[] = {2, 13, 17, 30, 45};

                int n1 = sizeof(ar1) / sizeof(ar1[0]);
                int n2 = sizeof(ar2) / sizeof(ar2[0]);
                if (n1 == n2)
                    cout << "Median is "
                        << getMedian(ar1, ar2, n1) ;
                else
                    cout << "Doesn't work for arrays"
                        << " of unequal size" ;
                getchar();
                return 0;
            }

    //App2: 
      //Solution: 


//Q30: Median of two sorted arrays of different sizes
  //Aproches:
     //App1:
       //Solution: 
         


//Q31: Repeat and Missing Number Array
   //Approches
     //App1:
       //Solutions:
         #include <bits/stdc++.h>
            using namespace std;
            int main()
            {   int a[]={2, 7, 1, 4, 5, 9, 3, 6, 8, 11, 12, 13, 10, 19, 16, 15, 17, 14, 18, 23, 22, 24, 12, 25, 20};
                int n=25;
                sort(a,a+n);
                int sum=0,c;
                for(int i=0;i<n;i++ ){
                    if(a[i]!=a[i+1]){
                        sum+=a[i];
                    }
                    else{
                        c=a[i];
                    }
                }
                int ans=(n*(n+1))/2;
                cout<<c<<" "<<ans-sum;
                return 0;
            }


//Q32:  Product of Array Except Self
   //Approches
     //App1:
       //Solutions
          #include <bits/stdc++.h>
            using namespace std;
            int main()
            {   int a[]={1,2,3,4};
            int n=4;
            int left[n],right[n];
            left[0]=right[n-1]=1;
            int j=n-2;
               for(int i=1;i<n;i++){
                   left[i]=left[i-1]*a[i-1];
                   right[j]=right[j+1]*a[j+1];
                   j--;
               }
               vector<int> v;
               for(int i=0;i<n;i++){
                   v.push_back(left[i]*right[i]);
               }
               for(int i=0;i<n;i++){
                   cout<<v[i]<<" ";
               }
                return 0;
            }


//Q33: 3sum
   //Approches
     //App1:
         For the given input array nums of size n this approach does the following steps:
            1:First step is to sort the given array nums. Sorting the array helps us identify duplicate triplets using our loops by skipping certain numbers that would 
                result in duplicate triplets. This helps us avoid using a hashmap to identify the duplicates (like in solution 1) there by improving the space complexity(Keep
                reading to know how duplicate triplets can be skipped). Also sorting the array helps efficiently increment/decrement our index variables depending on whether 
                the sum is less than or greater than 0.
            2:Next we need two loops. Outer loop index  num1Idx represents the index of the first element in the triplet. Inner loop contains two indexes num2Idx and 
               num3Idx representing the indexes of the 2nd and 3rd triplet elements respectively.
            3:Initially num1Idx points to the first element in the given array and num2Idx, num3Idx point to the 2nd and last elements in the given array. We fix the
               outer loop index num1Idx and move the two inner loop indexes inwards as long as num3Idx > num2Idx. Once the condition num3Idx > num2Idx is false we stop 
               the inner loop and increment the outer loop index num1Idx, also update num2Idx and num3Idx, num2Idx=num1Idx+1 and num3Idx=n-1.
            4:Take a variable sum to store the triplet sum. sum = nums[num1Idx] + nums[num2Idx] + nums[num3Idx]. Now there are three possibilities: a. If sum is equal to
              0 we add it to our result. b. If sum is greater than 0 we need to decrease the sum value to make it equal to 0, so we decrement num3Idx index. c. If sum is 
              less than 0 we need to increase sum value to make it equal to 0, so we increment num2Idx index.
            5:The inner loop should run as long as num3Idx > num2Idx for each iteration of the outer loop. We return the result once all the triplet combinations are processed.
            6: The above 4 steps ensure that we find all triplets whose sum is equal to 0. But it will also add duplicates to the result array. To skip duplicate 
               triplets we need to add two conditions to our algorithm, one in the outer loop and one in the inner loop. In the outer loop 
               if nums[num1Idx] == nums[num1Idx-1] i.e. if current num1Idx value is same as previous number (num1Idx-1) we skip the current number 
               (we don't have to consider the current number for calculating our result). This condition ensures that we skip all duplicates from the left side of the
               array. Similarly to skip all numbers from the right side of the array, once we find a triplet with sum equal to zero we keep decrementing num3Idx until 
               nums[num3Idx] != nums[num3Idx +1] (in the inner loop).

      //Solutions
         vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<vector<int>> ans;
        set<vector<int>>s;
        int j,k;
        for(int i=0;i<nums.size();i++){
            j=i+1; k=nums.size()-1;
            while(j<k){
                if(nums[i]+nums[j]+nums[k]==0){
                    s.insert({nums[i],nums[j],nums[k]});
                    k--;
                    j++;
                }
                else if((nums[i]+nums[j]+nums[k])<0){
                    j++;
                }
                else{
                    k--;
                }
            }  
            }
        for(auto i:s){
            ans.push_back(i);
        }
        return ans;
        }
