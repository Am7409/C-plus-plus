//Q1: Set Matrix Zeroes
  //Approches
    //App1: 
      1: In this problem we have to use the O(1) space so for this we have to make a indecator matrix inside the given matrix at the 0th postion of both the mXn sides.
      2: We have to make the two marker for to search that if there any zero present in the statring rows or columns, and than if yes than marks them for the future refrence
         than we have to check the matrix of the n-1 and m-1 part of the matrix, at this part we have find the cell which contains the zero and if zero if found in any cell 
         than mark the particulars cell's zeroth row and columns zero for the future use.
      3: After this make a row centric loop and check if the mat[i][0]=0 than the whole row is zero and similary the columns centric also. 
      4: And at the last check if the varabiles we check first if there values are zero than check the whole zeroth row and columns zero. 
        //Solutions: 
           void setZeroes(vector<vector<int>>& matrix) {
                    int x=1;
                    int y=1;
                    int m=matrix.size();
                    int n=matrix[0].size();
                    for(int i=0;i<m;i++){
                        if(matrix[i][0]==0){
                            y=0;
                        }
                    }
                     for(int j=0;j<n;j++){
                        if(matrix[0][j]==0){
                            x=0;
                        }
                    }
                     for(int i=1;i<m;i++){
                         for(int j=1;j<n;j++){
                             if(matrix[i][j]==0){
                                 matrix[0][j]=0;
                                 matrix[i][0]=0;
                             }
                        }
                    }
                    for(int i=1;i<m;i++){
                        if(matrix[i][0]==0){
                            for(int j=0;j<n;j++){
                                matrix[i][j]=0;
                            }
                        }
                    }
                    for(int j=1;j<n;j++){
                        if(matrix[0][j]==0){
                            for(int i=0;i<m;i++){
                                matrix[i][j]=0;
                            }
                        }
                    }
                    if(y==0){
                        for(int i=0;i<m;i++){
                            matrix[i][0]=0;
                        }
                    }
                    if(x==0){
                        for(int j=0;j<n;j++){
                            matrix[0][j]=0;
                        }
                    }
                }
                
                
//Q2: Word Search 
  //Approches: 
    //Appp1:  In this first we have to check from where the string was strated and than we have to check the conditions for the finding the other string members.
              for this first check all the pointer must inside the boundry and check the condtions using the recursion methods.
                         /* In this problem, we need to search if a given word exists inside a board[][] of characters
                            From one cell, we can move into it's 4 adjacent cells in the following directions - Down , Right , Up , Left
                            We cannot use one cell for more than once. Thus, backtracking comes into the picture*/
      //Solution:
          class Solution {
          private:

          bool search(int i , int j , int n , int m , vector<vector<char>> &board , string &word , int k)
          {
              // If k is equal to the given word's length, it means every character of word is present inside board[][], so we return true

              if(k == word.size() )
                 return true ;

              // If we are moving outside the board's boundary or if board[i][j] is not equal to word[k] , we return false

              if(i < 0 || j < 0 || i == n || j == m  || board[i][j] != word[k])
                  return false ;

              // We store the Character present in the current Cell inside ch variable 

              char ch = board[i][j] ;

              // We change board[i][j] to # so that we don't visit the Same Cell again

              board[i][j] = '#' ;

              // We move in Downward direction

              bool op1 = search(i + 1 , j , n , m , board , word , k + 1) ;

              // We move in Rightward direction

              bool op2 = search(i , j + 1 , n , m , board , word , k + 1) ;

              // We move in Upward direction

              bool op3 = search(i - 1 , j , n , m , board , word , k + 1) ;

              // We move in Leftward direction

              bool op4 = search(i , j - 1 , n , m , board , word , k + 1) ;

              // We backtrack and change the value of board[i][j] to it's original character stored in ch variable

              board[i][j] = ch ;

              // As we need to find the word, no matter from which direction we get it, so we return (op1 OR op2 OR op3 OR op4)

              return op1 || op2 || op3 || op4 ;
          }

          public:
              bool exist(vector<vector<char>>& board, string &word) {

              int n = board.size() ;
              int m = board[0].size() ;


              for(int i = 0 ; i < n ; i++)
              {
                  for(int j = 0 ; j < m ; j++)
                  {
                      // We start checking only if board[i][j] matches with word[0]

                      if(board[i][j] == word[0] )
                      {
                          // If our search results return True, we directly return true 

                          if(search(i , j , n , m , board , word , 0) )
                              return true ;
                      }
                  }
              }

              // Otherwise, if we searched the entire matrix and still didn't find the word, we return false 

              return false ; 
          }
          };

          /*
          Time Complexity:  O(N * M * 4^K)
          Space Complexity: O(K)
          K = word.size()
          */
              
              
//Q3:               
                
