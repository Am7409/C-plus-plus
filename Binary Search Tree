The Binary Search tree is the type of tree in which the left subtree is smaller than the root value and the right subtree is greater than the root value;
It is created using by the singley linked list;
Now the code to implement it on the compiler

              #include <bits/stdc++.h>

              using namespace std;

              class node{
                  public:
                  int data;
                  node* right;
                  node* left;
                  node(int d){
                      this->data=d;
                      this->left=NULL;
                      this->right=NULL;
                  }
              };
              node* insert(node* &root,int val){
                  if(root==NULL){
                      root = new node(val);
                     return root;
                  }
                  else if(val<root->data){
                      root->left=insert(root->left,val);
                  }
                  else if(val>root->data){
                      root->right=insert(root->right,val);
                  }
                  return root;
              }
              void print(node* root){
                  if(root==NULL){
                      return;
                  }
                  cout<<root->data<<" ";
                  print(root->left);
                  print(root->right);
              }
              int main()
              {
                  node* root=NULL;
                  root=insert(root,45);
                 root=insert(root,4);
                 root=insert(root,65);
                 root=insert(root,40);
                 root=insert(root,450);

                  print(root);

                  return 0;
              }


 Q2 : Predecessor and Successor
    //Approches
      //App1 : For this we have to find the pre value of the given key in the preorder tree
               So to find this for finding the predecessor we have first go to the left from the key and than go to the extreem right 
               And find the successor we have to firstly go to the right and go to the extreem left so that to find out the successor 
               and if the given key is greater than we have to update the successor and than to solve the case of the leaf node;
               
      //Solutions
         Node* inpre(Node* root){
            Node* temp=root->left;
            while(temp->right!=NULL){
                temp=temp->right;
            }
            return temp;
        }
        Node* insuc(Node* root){
            Node* temp=root->right;
            while(temp->left!=NULL){
                temp=temp->left;
            }
            return temp;
        }
        void findPreSuc(Node* root, Node*& pre, Node*& suc, int key)
        {

        // Your code goes here

        if(root==NULL){
            return;
        }
        if(root->key == key){
            if(root->left) pre=inpre(root);
            if(root->right) suc=insuc(root);
            return;
        }
        if(key > root->key){
            pre=root;
            findPreSuc(root->right,pre,suc,key);
        }
        else if(key < root->key){
            suc=root;
            findPreSuc(root->left,pre,suc,key);
        }

        }
